#Demographic Methods - Practical 9 (Cohort fertility and parity progression), by JE Romero-Prieto, PhD#
#https://github.com/Romero-Prieto/teaching#
# The heading
rm(list = ls())                                                                 #Clearing all generated data if any.
#install.packages("ggplot2")
#install.packages("data.table")
library(ggplot2)                                                                #To draw plots.                 
library(data.table)                                                             #To make high-performance data manipulation using tables.

# Reading the data (cohort fertility)
GitHub               = "https://raw.githubusercontent.com/Romero-Prieto/teaching/main/Demographic%20Methods/practical_9.csv"
data                 = read.csv(GitHub)                                         #Reads age-period-cohort estimates of exposure PY, and the corresponding number of births B. Sweden female population from 1891 to 2024.
data                 = as.data.table(data)                                      #Defines data as a table, which is convenient for data analysis and preparation.
setorder(data, "Year", "x")                                                     #Sorts data by year and age (in that order).
print(data[10:15, ])                                                            #Shows 5 selected rows of the data.

# Some syntax for data preparation 
subset               = data[["Cohort"]]                                         #Selects all elements of the "Cohort" column in the "data" table.
sEL                  = data[["Cohort"]] > 1990                                  #Generates a logical variable that identifies cohorts born in 1991 or later.
subset               = data[["Cohort"]][sEL]                                    #Selects the "sEL" elements of the "Cohort" column in the "data" table. "sEL" can be either a list of elements or a logical vector with the same length as the rows of "data".
subset               = data[, c("Cohort", "Year")]                              #Extracts a subsidiary table from the "data", including all observations but restricted to the columns "Cohort" and "Year".
subset               = data[sEL, c("Cohort", "Year")]                           #Extract a subsidiary table from the "data", restricted to the "sEL" observations and the columns "Age" and "Cohort".
subset               = data[Cohort >= 1950 & Cohort < 1970, 
                            list(B = sum(B, na.rm = TRUE), PY = sum(PY, na.rm = TRUE)), 
                            by = list(Year, x)][order(Year, x)]                 #Collapses the table "data" for a selection of cohorts (i.e., from 1950 to 1969), adding the number of births ("B") and the number of person-years ("PY") by each combination of "Year" and "x" and ignoring NA values. The resulting table is ordered by "Year" and "x".

# Data preparation (cohort fertility)
cohort               = data[, list(B = sum(B, na.rm = TRUE), PY = sum(PY, na.rm = TRUE)), by = list(Cohort, x)][order(Cohort, x)] #Collapses the data, adding the values of B and PY for each age and cohort. NA values are ignored. The resulting table is sorted by cohort and age. 
cohort               = cohort[!is.na(cohort[["Cohort"]])]                       #Removes values with unknown cohort.
cohort[["rEP"]]      = cohort[["x"]] >= 15 & cohort[["x"]] < 50                 #Defines a column that indicates standard reproductive ages.
sEL                  = cohort[, list(rEP = sum(rEP, na.rm = TRUE)), by = list(Cohort)] #Collapse the table again, to consolidate the number of reproductive ages per cohort. 
sEL                  = sEL[,"Cohort"][sEL[["rEP"]] == 35]                       #Identifies cohorts with complete fertility schedules.
cohort               = cohort[sEL, on = "Cohort"]                               #Merges tables sEL and cohort—and retains only cohorts with complete fertility schedules.

period               = data[, list(B = sum(B, na.rm = TRUE), PY = sum(PY, na.rm = TRUE)), by = list(Year, x)][order(Year, x)] #Follows the same steps to prepare a table for period analysis.
period[["rEP"]]      = period[["x"]] >= 15 & period[["x"]] < 50                 #Defines a column that indicates standard reproductive ages.
sEL                  = period[, list(rEP = sum(rEP, na.rm = TRUE)), by = list(Year)] #Collapse the table again, to consolidate the number of reproductive ages per year. 
sEL                  = sEL[,"Year"][sEL[["rEP"]] == 35]                         #Identifies years with complete fertility schedules.
period               = period[sEL, on = "Year"]                                 #Retains only years with complete fertility schedules.


# Example questions
# Calculate the following values for the 1970 cohort:
# a. Total Fertility Rate of the Cohort (TFRc).
# Hint: A new column "NnFx" can be generated by multiplying the age-specific fertility rates by the corresponding length of the age intervals. Then, these values should be aggregated for the selected cohort and across the defined range of reproductive ages (i.e., "cohort[["rEP"]] == 1").
cohort[["NnFx"]]     = cohort[["B"]]/cohort[["PY"]]*1
TFRc                 = sum(cohort[["NnFx"]][cohort[["rEP"]] == 1 & cohort[["Cohort"]] == 1970])
print(data.frame(TFRc), row.names = FALSE)
# Alternatively, collapsing the table for the same selection.
print(data.frame(cohort[rEP == 1 & Cohort == 1970, list(TFR = sum(NnFx, na.rm = TRUE)), by = list(Cohort)]), row.names = FALSE)

# b. Mean Age of the Fertility Schedule of the Cohort (mu_cf).  
# Hint: A new column can be generated by multiplying the mid-point age (i.e., x + 0.5) by "NnFx". Then, these values should be aggregated for the selected cohort and across the defined range of reproductive ages, and finally divided by the "TFRc".
cohort[["mu"]]       = cohort[["NnFx"]]*(cohort[["x"]] + .5)
TFRc                 = cohort[rEP == 1 & Cohort == 1970, list(TFR = sum(NnFx, na.rm = TRUE), mu = sum(mu, na.rm = TRUE)), by = list(Cohort)]
TFRc[["mu"]]         = TFRc[["mu"]]/TFRc[["TFR"]]
print(data.frame(TFRc), row.names = FALSE)

# Calculate the following values for the year 2000:
# c. Total Fertility Rate (TFR) and Mean Age of the Fertility Schedule (mu_f).  
# Hint: The same approach outlined in questions a and b can be applied; however, in this case, a specific year should be selected from the period table.
period[["NnFx"]]     = period[["B"]]/period[["PY"]]*1
period[["mu"]]       = period[["NnFx"]]*(period[["x"]] + .5)
TFR                  = period[rEP == 1 & Year == 2000, list(TFR = sum(NnFx, na.rm = TRUE), mu = sum(mu, na.rm = TRUE)), by = list(Year)]
TFR[["mu"]]          = TFR[["mu"]]/TFR[["TFR"]]
print(data.frame(TFR), row.names = FALSE)

# Exercise 1: Cohort Fertility (Compulsory)
# a. Calculate the Total Fertility Rate (TFRc) and the Mean Age of the Fertility (mu_cf) for all cohorts.  
# Hint: The same approach described in the example questions can be applied. Since the columns "NnFx" and "mu" were generated as part of the example, the only remaining step is to collapse the cohort table. However, in this case, it is not necessary to select a specific cohort.

# b. Calculate the Total Fertility Rate (TFR) and the Mean Age of the Fertility (mu_f) for all years.
# Hint: The approach followed in the previous questions should be applied, with the additional step of collapsing the period table to include all available years.

# Exercise 2: Cohort Fertility (Compulsory)
# As a contrast, plot the TFR and the TFRc in the same figure. Discuss your results.
# Hint: To make these two to measures time-comparable, plot the period TFR at the mid-year (i.e., Year + 0.5) and the TFRc at the year of birth plus the Mean Age of the Fertility Schedule (i.e., Cohort + mu_cf).

# Exercise 3: Parity Progression
GitHub               = "https://raw.githubusercontent.com/Romero-Prieto/teaching/main/Demographic%20Methods/practical_9B.csv"
data                 = read.csv(GitHub)                                         #Reads an excerpt of individual-level data from the UNICEF Multiple Indicator Cluster Survey (MICS). Women aged 45-49 interviewed in Malawi in 2019-20. The file includes the parity (i.e., total number of children ever born), the place of residence (UB, urban = 1, rural = 2), the level of education (less than complete primary = 1, incomplete secondary = 2, complete secondary or higher = 3), and a relative sampling weights.
data                 = as.data.table(data)                                      #Defines data as a table, which is convenient for data analysis.
data                                                                            #Prints subset of records.
# Example questions
# a. Calculate the Parity Progression Ratios and the TFR for this cohort.
# Hint: A collapsed and sorted table can be generated by parity. In some cases, one or more parities might lack empirical support (i.e., the maximum parity is 15, but no woman reported having 13 children). Hence, to avoid potential errors, it is good practice to create a data frame that includes all parities from 0 up to the maximum number of children ever born, and then allocate the empirical data to that frame, as described by the following three lines of code:
summary              = data[, list(Wi = sum(W, na.rm = TRUE)), by = list(Parity)][order(Parity)] #Collapse and sort the data, adding the number of women for each parity.
PPR                  = data.table(Parity = 0:max(data[["Parity"]]), Wi = rep(0,max(data[["Parity"]]) + 1)) #Creates a frame which is including all possible parities (from zero to the reported maximum number of children ever born).
setDT(PPR)[summary, on = "Parity", c("Wi") := list(i.Wi)]                       #Merges and updates the PPR table using matching information from the summary table.
PPR[["Pi"]]          = rev(cumsum(rev(PPR[["Wi"]])))                            #Quantifies the number of women with parity less than or equal to i (Pi).
PPR[["PPRi"]]        = c(NA,tail(PPR[["Pi"]],-1)/head(PPR[["Pi"]],-1))          #Quantifies the proportion of women progressing from parity i — 1 to i (PPRi). Functions head(object, -index) and tail(object, -index), are used to omit the first or the last element of object.
PPR[["PPRoi"]]       = c(NA,cumprod(tail(PPR[["PPRi"]],-1)))                    #Quantifies the proportion of women progressing from parity 0 to i (PPRoi).
TFRc                 = sum(tail(PPR[["PPRoi"]],-1))                             #Calculates the TFRc from the Parity Progression Ratios from 0 to parity i.
print(data.frame(PPR), row.names = FALSE)                                       #Displays the resulting Parity Progression table.
print(data.frame(TFRc), row.names = FALSE)                                      #Displays the resulting TFRc.

# b. Calculate the probability that a woman of this cohort would have 3 children.
# Hint: Using the column Wi, calculate the proportion of women with exactly three children.
PPR[["Wi"]][PPR[["Parity"]] == 3]/PPR[["Pi"]][PPR[["Parity"]] == 0]

# c. Calculate the probability that a woman of this cohort would have at least 3 children.
# Hint: Report the PPR from 0 to 3.
PPR[["PPRoi"]][PPR[["Parity"]] == 3]

# d. Calculate the probability that a woman of this cohort would have at least 3 children if she already have one child (progression form 1 to 3).  
# Hint: Divide the PPR from 0 to 3 by the PPR from 0 to 1.
PPR[["PPRoi"]][PPR[["Parity"]] == 3]/PPR[["PPRoi"]][PPR[["Parity"]] == 1]

# Compulsory questions
# a. Using Parity Progression tables, calculate the Urban-Rural TFR gap for this cohort and comment on your results. 
# Hint: Using the code from the example question, a temporary function named fertility can be defined to return the TFRc for a given input data, in the following form: "fertility = function(data) { list of operations }". Next, evaluate the function on a subset of the data representing either urban or rural residents (e.g., "result = fertility(data[data[["UR"]] == 1])"). Finally, calculate the gap as the difference between the TFRc values for rural and urban residents.

# b. Using Parity Progression tables, calculate the TFR for each level of education of this cohort and comment on your results.**  
# Hint: Use the fertility function to evaluate the subset of data for women with different levels of education (e.g., "result = fertility(data[data[["Education"]] == 1])").
